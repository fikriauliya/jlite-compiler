Parsing...
p1.jlite

======= JLite Program =======

class P1{
  void main(Int a){
    Int dummy1;
    String dummy2;
    Int x;
    AlwaysDivide ad;
    AlwaysDivideRecursive adr;
    println("Hello world");
    x=0;
    readln(x);
    ad=new AlwaysDivide();
    ad.min=x;
    [ad.printDivide(100)];
    [ad.doNothing()];
    adr=new AlwaysDivideRecursive();
    adr.min=x;
    [adr.printDivideRecursive(100)];
    println("Goodbye cruel world!");
  }

} 

class DivideByX{
  Int x;

  Int divide(Int a){
    Return [a,x](/);
  }

}
class AlwaysDivide{
  Int min;

  void printDivide(Int start){
    Int dummy1;
    String dummy2;
    While([start,min](>=)) {
  println(start);
  start=[start,2](/);
}
  }


  void doNothing(){
    While(true) {
  println("qqq");
}
  }

}
class AlwaysDivideRecursive{
  Int min;

  void printDivideRecursive(Int start){
    If([start,min](>=))
    {
      println(start);
      [printDivideRecursive([start,2](/))];
    }
    else
    {
      Return;
    }
  }

}
class AlwaysDivideIterative{

  Int printDivideIterative(Int start,Int end){
    While([start,end](>)) {
  If([start,end](==))
  {
    Return 9000;
  }
  else
  {
    start=[start,2](/);
  }
}
    Return 42;
  }


  AlwaysDivideIterative get(){
    If(true)
    {
      Return new AlwaysDivideIterative();
    }
    else
    {
      println("aaa");
      If(false)
      {
        println("falsefalse");
        Return null;
      }
      else
      {
        println("falsetrue");
        Return null;
      }
    }
  }

}
class AlwaysDivideRecursiveFixed{

  void printDivideRecursive(Int start){
    If([start,2](>=))
    {
      println(start);
      [this.printDivideRecursive([start,2](/))];
    }
    else
    {
      Return;
    }
  }

}

======= End of JLite Program =======


======= JLite Program =======

class P1{
  void main(Int a){
    Int dummy1;
    String dummy2;
    Int x;
    AlwaysDivide ad;
    AlwaysDivideRecursive adr;
    println("Hello world":String);
    (x:Int,2)=0:Int;
    readln((x:Int,2));
    (ad:AlwaysDivide,2)=new AlwaysDivide():AlwaysDivide;
    (ad:AlwaysDivide,2):AlwaysDivide.min:Int=(x:Int,2):Int;
    [(ad:AlwaysDivide,2):AlwaysDivide.printDivide:AlwaysDivide(100:Int)]:void;
    [(ad:AlwaysDivide,2):AlwaysDivide.doNothing:AlwaysDivide()]:void;
    (adr:AlwaysDivideRecursive,2)=new AlwaysDivideRecursive():AlwaysDivideRecursive;
    (adr:AlwaysDivideRecursive,2):AlwaysDivideRecursive.min:Int=(x:Int,2):Int;
    [(adr:AlwaysDivideRecursive,2):AlwaysDivideRecursive.printDivideRecursive:AlwaysDivideRecursive(100:Int)]:void;
    println("Goodbye cruel world!":String);
  }

} 

class DivideByX{
  Int x;

  Int divide(Int a){
    Return [(a:Int,2):Int,(x:Int,1):Int](/):Int;
  }

}
class AlwaysDivide{
  Int min;

  void printDivide(Int start){
    Int dummy1;
    String dummy2;
    While([(start:Int,2):Int,(min:Int,1):Int](>=):Bool) {
  println((start:Int,2):Int);
  (start:Int,2)=[(start:Int,2):Int,2:Int](/):Int;
}
  }


  void doNothing(){
    While(true:Bool) {
  println("qqq":String);
}
  }

}
class AlwaysDivideRecursive{
  Int min;

  void printDivideRecursive(Int start){
    If([(start:Int,2):Int,(min:Int,1):Int](>=):Bool)
    {
      println((start:Int,2):Int);
      [printDivideRecursive([(start:Int,2):Int,2:Int](/):Int)]:void;
    }
    else
    {
      Return;
    }
  }

}
class AlwaysDivideIterative{

  Int printDivideIterative(Int start,Int end){
    While([(start:Int,2):Int,(end:Int,2):Int](>):Bool) {
  If([(start:Int,2):Int,(end:Int,2):Int](==):Bool)
  {
    Return 9000:Int;
  }
  else
  {
    (start:Int,2)=[(start:Int,2):Int,2:Int](/):Int;
  }
}
    Return 42:Int;
  }


  AlwaysDivideIterative get(){
    If(true:Bool)
    {
      Return new AlwaysDivideIterative():AlwaysDivideIterative;
    }
    else
    {
      println("aaa":String);
      If(false:Bool)
      {
        println("falsefalse":String);
        Return null:null;
      }
      else
      {
        println("falsetrue":String);
        Return null:null;
      }
    }
  }

}
class AlwaysDivideRecursiveFixed{

  void printDivideRecursive(Int start){
    If([(start:Int,2):Int,2:Int](>=):Bool)
    {
      println((start:Int,2):Int);
      [this:AlwaysDivideRecursiveFixed.printDivideRecursive:AlwaysDivideRecursiveFixed([(start:Int,2):Int,2:Int](/):Int)]:void;
    }
    else
    {
      Return;
    }
  }

}

======= End of JLite Program =======

======= IR3 Program =======

======= CData3 ======= 

class P1{
}

class DivideByX{
  Int x;
}

class AlwaysDivide{
  Int min;
}

class AlwaysDivideRecursive{
  Int min;
}

class AlwaysDivideIterative{
}

class AlwaysDivideRecursiveFixed{
}

=======  CMtd3 ======= 

void P1_main_Int(P1 this,Int a){
  Int dummy1;
  String dummy2;
  Int x;
  AlwaysDivide ad;
  AlwaysDivideRecursive adr;
  String _t1;
  Int _t2;
  void _t3;
  void _t4;
  Int _t5;
  void _t6;
  String _t7;
  _t1="Hello world";
  println(_t1);
  x=0;
  readln(x);
  ad=new AlwaysDivide();
  ad.min=x;
  _t2=100;
  _t3=[AlwaysDivide_printDivide_Int(ad,_t2)];
  _t3;
  _t4=[AlwaysDivide_doNothing_void(ad)];
  _t4;
  adr=new AlwaysDivideRecursive();
  adr.min=x;
  _t5=100;
  _t6=[AlwaysDivideRecursive_printDivideRecursive_Int(adr,_t5)];
  _t6;
  _t7="Goodbye cruel world!";
  println(_t7);
}

Int DivideByX_divide_Int(DivideByX this,Int a){
  Int _t8;
  Int _t9;
  _t8=this.x;
  _t9=[a,_t8](/);
  Return _t9;
}

void AlwaysDivide_printDivide_Int(AlwaysDivide this,Int start){
  Int dummy1;
  String dummy2;
  Int _t12;
  Bool _t13;
  Int _t14;
 Label 3:
  _t12=this.min;
  _t13=[start,_t12](>=);
  If([_t13,false](==)) goto 4;
  println(start);
  _t14=2;
  start=[start,_t14](/);
  goto 3;
 Label 4:
}

void AlwaysDivide_doNothing_void(AlwaysDivide this){
  Bool _t10;
  String _t11;
 Label 1:
  _t10=true;
  If([_t10,false](==)) goto 2;
  _t11="qqq";
  println(_t11);
  goto 1;
 Label 2:
}

void AlwaysDivideRecursive_printDivideRecursive_Int(AlwaysDivideRecursive this,Int start){
  Int _t15;
  Bool _t16;
  Int _t17;
  Int _t18;
  void _t19;
  _t15=this.min;
  _t16=[start,_t15](>=);
  If([_t16,false](==)) goto 5;
  println(start);
  _t17=2;
  _t18=[start,_t17](/);
  _t19=[AlwaysDivideRecursive_printDivideRecursive_Int(this,_t18)];
  _t19;
  goto 6;
 Label 5:
  Return;
 Label 6:
}

Int AlwaysDivideIterative_printDivideIterative_Int_Int(AlwaysDivideIterative this,Int start,Int end){
  Bool _t26;
  Bool _t27;
  Int _t28;
  Int _t29;
  Int _t30;
 Label 11:
  _t26=[start,end](>);
  If([_t26,false](==)) goto 12;
  _t27=[start,end](==);
  If([_t27,false](==)) goto 13;
  _t28=9000;
  Return _t28;
  goto 14;
 Label 13:
  _t29=2;
  start=[start,_t29](/);
 Label 14:
  goto 11;
 Label 12:
  _t30=42;
  Return _t30;
}

AlwaysDivideIterative AlwaysDivideIterative_get_void(AlwaysDivideIterative this){
  Bool _t20;
  AlwaysDivideIterative _t21;
  String _t22;
  Bool _t23;
  String _t24;
  String _t25;
  _t20=true;
  If([_t20,false](==)) goto 7;
  _t21=new AlwaysDivideIterative();
  Return _t21;
  goto 8;
 Label 7:
  _t22="aaa";
  println(_t22);
  _t23=false;
  If([_t23,false](==)) goto 9;
  _t24="falsefalse";
  println(_t24);
  Return null;
  goto 10;
 Label 9:
  _t25="falsetrue";
  println(_t25);
  Return null;
 Label 10:
 Label 8:
}

void AlwaysDivideRecursiveFixed_printDivideRecursive_Int(AlwaysDivideRecursiveFixed this,Int start){
  Int _t31;
  Bool _t32;
  Int _t33;
  Int _t34;
  void _t35;
  _t31=2;
  _t32=[start,_t31](>=);
  If([_t32,false](==)) goto 15;
  println(start);
  _t33=2;
  _t34=[start,_t33](/);
  _t35=[AlwaysDivideRecursiveFixed_printDivideRecursive_Int(this,_t34)];
  _t35;
  goto 16;
 Label 15:
  Return;
 Label 16:
}

======= End of IR3 Program =======

